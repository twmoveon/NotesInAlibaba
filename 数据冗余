数据冗余

关系数据库的数据冗余形成的原因：表的重复、属性的重复、元组的重复、属性值的重复。有的数据冗余用于数据间建立联系、数据安全或为了数据使用的便利，是必需的数据冗余，而其余的数据冗余为非必需的数据冗余应尽量予以消除。按属性值域集合基的特点将其分为有限类和无限类。无限类属性值偶尔重复不是数据冗余，有限类属性值的重复由一对多或多对多的关系所致，可相机处理之。

 

关系数据库中的数据冗余主要是指关系数据库中同一信息数据的重复存贮。
　　数据冗余浪费了宝贵的资源，应尽量减少。但关系数据库中为实现一些功能有些数据冗余是必需的。必需的数据冗余主要用于以下用途：
(1)数据间建立联系，如两表间通过共同属性建立联系；

(2)数据恢复，如建立备份文件以备正式文件被破坏时恢复；
　　(3)数据核查，如设立数据校验位可以检查数据在存贮、传输等过程中的改变；
　　(4)数据使用的便利，如为了查看数据的直观，使用数据的方便、高效。
　　(5)减少数据通讯开销，如分布式数据库在不同场地重复。

 

2.       数据冗余的成因
关系数据库由表及附属文件组成，其表由属性定义的结构和元组（记录）组成，其属性值域有多种类型，故关系数据库的数据冗余形成的原因有表的重复、属性的重复、元组的重复、属性值的重复4类。
2.1　表的重复
　　为了数据安全的需要制作备份表，当主表被破坏时可用此恢复数据。分布式数据库为减少数据通讯开销也常重复放表，这种数据冗余在这里是必需数据冗余，不能删除。若是因其他原因产生的非必要的重复表则应予以删除。
2.2　属性重复
　　有不同表的属性重复和同一表内属性重复2种情况：
　　(1)  不同表中属性重复常用来建立表之间联系，这只需要一个公共属性，这是必需数据冗余，不能删除；各表间的多于一个的属性应当删除。如有以下3个表：

T1(A,B,C)；T2(A,B,D)；T3(A,C,D,E)。

其中属性A为三表所共有；属性B为T1,T2 两张表所共有，属性C为T1，T3 两张表所共有；属性D为T2，T3 二表所共有。如取A为公共属性则，T1，T2 两张表中只能保留一个B属性；T1，T3 两张表中只能保留一个C属性；T2，T3 两张表中只能保留一个D属性。
　　(2)  同一表内有相同属性内容的多个属性，若非数据安全检查的需要，应删除之。
2.3　元组的重复
　　表内不同记录内容有时会完全相同，若非必要，应予以删除。
2.4　属性值的重复
　　按属性值域集合基的特点可以将其分为有限类和无限类。
　　(1)  无限类属性值的重复。无限类属性值是指其属性值域集合的基为无限大或者数据库记录数为同一数量级的属性值，如实数、整数、日期、各种编号。
　　无限类属性值偶尔也可能重复，但这只是巧合，而并非数据冗余。
　　(2)  有限类属性值的重复。有限类属性值是指其属性值域集合的基小于数据库记录数至少一个数量级的属性值，如产品名，部门名，职称名，课程名。
　　有限类属性值的重复实际上是由一对多或多对多的关系引起的，有时可作为必需冗余数据不予以处理，这时不需程序就有较好的查看效果和工作效率。但当重复量很大时，也应当设法对所引起的数据冗余进行压缩，这通常要建立新表和相应的程序。

2.5 不同成因的数据冗余用不同层次上的操作来消除。

                   （1）消除表的重复所引起的数据冗余为磁盘文件级的操作。

                   （2）属性的重复所引起的数据冗余的消除为对数据库结构修改的操作。
                   （3）元组的重复所引起的数据冗余的消除由记录级的操作完成。

3. 数据冗余的缺点：

a)   存储空间的浪费。

b)   数据交互和数据库访问执行效率降低。

代码的冗余  可以用存储过程来解决
删除冗余数据：用一个PL/SQL 方案（一个自定义的存储过程）或者一个SQL语句的解决方案（使用一个分析的函数RANK（）和一个嵌套的子查询）来消除冗余数据然后控制应该保留的记录，详细见参考资料2
减少冗余数据：使用范式设计。
常见类型数据库设计技巧、模型，详见参考资料3
 

 

 

 

附：

1.       题外：数据库的最初雏形据说源自美国一个奶牛场的记账薄(纸质的，由此可见，数据库并不一定是存储在电脑里的数据^_^)，里面记录的是该奶牛场的收支账目，程序员在将其整理、录入到电脑中时从中受到启发。当按照规定好的数据结构所采集到的数据量大到一定程度后，出于程序执行效率的考虑，程序员将其中的检索、更新维护等功能分离出来，做成单独调用的模块，这个模块后来就慢慢发展、演变成现在我们所接触到的数据库管理系统(DBMS)——程序开发中的一个重要分支。
2.       数据库范式设计：
数据库范式是数据库设计中必不可少的知识，没有对范式的理解，就无法设计出高效率、优雅的数据库，甚至设计出错误的数据库。

a)         第一范式(1NF)：属性不可分

b)         第二范式(2NF)：符合1NF，并且，非主属性完全依赖于码。

c)         第三范式(3NF)：符合2NF，并且，消除传递依赖

d)         BC范式(BCNF)：符合3NF，并且，主属性不依赖于主属性（如果关系模式属于第一范式，且每个属性都不传递依赖于键码，则R属于BC范式）。
